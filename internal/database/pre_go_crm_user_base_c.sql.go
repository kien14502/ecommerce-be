// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: pre_go_crm_user_base_c.sql

package database

import (
	"context"
	"database/sql"
)

const checkUserBaseExists = `-- name: CheckUserBaseExists :one
SELECT COUNT(*) 
FROM pre_go_acc_user_base_9999 
WHERE user_account = ?
`

func (q *Queries) CheckUserBaseExists(ctx context.Context, userAccount string) (int64, error) {
	row := q.db.QueryRowContext(ctx, checkUserBaseExists, userAccount)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createUserBase = `-- name: CreateUserBase :execresult
INSERT INTO pre_go_acc_user_base_9999 (
    user_account, 
    user_password, 
    user_salt, 
    user_login_ip
) VALUES (?, ?, ?, ?)
`

type CreateUserBaseParams struct {
	UserAccount  string
	UserPassword string
	UserSalt     string
	UserLoginIp  sql.NullString
}

func (q *Queries) CreateUserBase(ctx context.Context, arg CreateUserBaseParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, createUserBase,
		arg.UserAccount,
		arg.UserPassword,
		arg.UserSalt,
		arg.UserLoginIp,
	)
}

const deleteUserBase = `-- name: DeleteUserBase :exec
DELETE FROM pre_go_acc_user_base_9999 
WHERE user_id = ?
`

func (q *Queries) DeleteUserBase(ctx context.Context, userID int32) error {
	_, err := q.db.ExecContext(ctx, deleteUserBase, userID)
	return err
}

const getUserBaseByAccount = `-- name: GetUserBaseByAccount :one
SELECT user_id, user_account, user_password, user_salt
FROM pre_go_acc_user_base_9999
WHERE user_account = ?
LIMIT 1
`

type GetUserBaseByAccountRow struct {
	UserID       int32
	UserAccount  string
	UserPassword string
	UserSalt     string
}

func (q *Queries) GetUserBaseByAccount(ctx context.Context, userAccount string) (GetUserBaseByAccountRow, error) {
	row := q.db.QueryRowContext(ctx, getUserBaseByAccount, userAccount)
	var i GetUserBaseByAccountRow
	err := row.Scan(
		&i.UserID,
		&i.UserAccount,
		&i.UserPassword,
		&i.UserSalt,
	)
	return i, err
}

const getUserBaseById = `-- name: GetUserBaseById :one
SELECT user_id, user_account, user_password, user_salt, user_login_ip, user_created_at, user_updated_at
FROM pre_go_acc_user_base_9999
WHERE user_id = ?
LIMIT 1
`

type GetUserBaseByIdRow struct {
	UserID        int32
	UserAccount   string
	UserPassword  string
	UserSalt      string
	UserLoginIp   sql.NullString
	UserCreatedAt sql.NullTime
	UserUpdatedAt sql.NullTime
}

func (q *Queries) GetUserBaseById(ctx context.Context, userID int32) (GetUserBaseByIdRow, error) {
	row := q.db.QueryRowContext(ctx, getUserBaseById, userID)
	var i GetUserBaseByIdRow
	err := row.Scan(
		&i.UserID,
		&i.UserAccount,
		&i.UserPassword,
		&i.UserSalt,
		&i.UserLoginIp,
		&i.UserCreatedAt,
		&i.UserUpdatedAt,
	)
	return i, err
}

const listUsersBase = `-- name: ListUsersBase :many
SELECT user_id, user_account, user_created_at
FROM pre_go_acc_user_base_9999
ORDER BY user_created_at DESC
LIMIT ? OFFSET ?
`

type ListUsersBaseParams struct {
	Limit  int32
	Offset int32
}

type ListUsersBaseRow struct {
	UserID        int32
	UserAccount   string
	UserCreatedAt sql.NullTime
}

func (q *Queries) ListUsersBase(ctx context.Context, arg ListUsersBaseParams) ([]ListUsersBaseRow, error) {
	rows, err := q.db.QueryContext(ctx, listUsersBase, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListUsersBaseRow
	for rows.Next() {
		var i ListUsersBaseRow
		if err := rows.Scan(&i.UserID, &i.UserAccount, &i.UserCreatedAt); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateUserBaseLoginInfo = `-- name: UpdateUserBaseLoginInfo :exec
UPDATE pre_go_acc_user_base_9999
SET 
    user_login_time = CURRENT_TIMESTAMP(),
    user_login_ip = ?,
    user_updated_at = CURRENT_TIMESTAMP()
WHERE user_id = ?
`

type UpdateUserBaseLoginInfoParams struct {
	UserLoginIp sql.NullString
	UserID      int32
}

func (q *Queries) UpdateUserBaseLoginInfo(ctx context.Context, arg UpdateUserBaseLoginInfoParams) error {
	_, err := q.db.ExecContext(ctx, updateUserBaseLoginInfo, arg.UserLoginIp, arg.UserID)
	return err
}

const updateUserBasePassword = `-- name: UpdateUserBasePassword :exec
UPDATE pre_go_acc_user_base_9999
SET 
    user_password = ?,
    user_salt = ?,
    user_updated_at = CURRENT_TIMESTAMP()
WHERE user_id = ?
`

type UpdateUserBasePasswordParams struct {
	UserPassword string
	UserSalt     string
	UserID       int32
}

func (q *Queries) UpdateUserBasePassword(ctx context.Context, arg UpdateUserBasePasswordParams) error {
	_, err := q.db.ExecContext(ctx, updateUserBasePassword, arg.UserPassword, arg.UserSalt, arg.UserID)
	return err
}
